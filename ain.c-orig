/*
 *
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <GL/glut.h>

// Maximum number of particles
int max_particles = 80;
int tailp = 100;


typedef struct particle{
  float x[120];
  float y[120];
} Particle_t;

Particle_t *pSet;


// delta T and T
float dt = 0.003;
float T = 0.0;

// region of particles are genarated
float x_1 = 0.2;
float y_1 = 0.6;
float x_2 = 0.4;
float y_2 = 0.3;

void key_w(){dt = dt*2;}
void key_s(){dt = dt/2;}

void keyPress( unsigned char key, int x, int y ){
  switch (key){
  case 'W':
  case 'w':
    key_w();
    break;
  case 'S':
  case 's':
    key_s();
    break;
  case 27:
    exit(1);
  }
}

void specialKey(int key, int x, int y){
  switch (key){
  case GLUT_KEY_UP:
    if (y_1 < 0.96){
      y_1 += 0.05;
      y_2 += 0.05;
    }
    break;
  case GLUT_KEY_DOWN:
    if(y_2>0.04){
      y_1 -= 0.05;
      y_2 -= 0.05;
    }
    break;
  case GLUT_KEY_RIGHT:
    if(x_2< 0.96){
      x_1 += 0.05;
      x_2 += 0.05;
    }
    break;
  case GLUT_KEY_LEFT:
    if(x_1>0.04){
      x_1 -= 0.05;
      x_2 -= 0.05;
    }
    break;
  }
}

float xVectorF(float x, float y){
  //return ((0.7-x)/(2+T));
  //return sin(2*T-0.5) +(0.3 - x);
  //return sin(2*T-0.5);
  return 2*(0.5 - y);
}

float yVectorF(float x, float y){
  //return (T*(T -y)/ 2);
  //return cos(7*T) + (0.5 - y);
  //return cos(7*T)-4*(pow((x-0.5), 2.0));
  return cos(T)*(x-0.5);
}


void createParticle(int i){
  int j;
  float x = x_1 + (x_2-x_1)*((float)(rand()%100)) / 100.0;
  float y = y_2 + (y_1-y_2)*((float)(rand()%100)) / 100.0;
  for (j=0; j<tailp; j++){
    pSet[i].x[j] = x;
    pSet[i].y[j] = y;
  }
}


void initParticles(){
  int i, j;
  srand(time(NULL));
  pSet = (Particle_t *) malloc(max_particles*sizeof(Particle_t));
  for (i=0; i<max_particles; i++){
    createParticle(i);
  }

}


void drawParticles(){

  int i, j;
  glColor3f(0.0, 0.940, 0.30);
  //glColor3f(1.0, 1.0, 1.0);
  glBegin(GL_POINTS);
  for (i=0; i<max_particles; i++){

    if(pSet[i].y[0]>1.0 || pSet[i].x[0]>1.0 || pSet[i].x[0]<0.0 || pSet[i].y[0]<0.0)
      createParticle(i);

    for(j=0; j<tailp; j++){
      if(j <tailp-1){
	pSet[i].x[j] = pSet[i].x[j+1];
	pSet[i].y[j] = pSet[i].y[j+1];
      } else {
	pSet[i].x[j] = pSet[i].x[j] + xVectorF(pSet[i].x[j], pSet[i].y[j]) * dt;
	pSet[i].y[j] = pSet[i].y[j] + yVectorF(pSet[i].x[j], pSet[i].y[j]) * dt;
      }
      glVertex3f(pSet[i].x[j], pSet[i].y[j], 0.0);
    }

  }
  glEnd();


}

void drawGrid(){

  int i,j, gridsize = 15;
  float veclen = 0.02f;

  glColor3f(0.10, 0.40, 0.60);
  glBegin(GL_LINES);
  for (i=1; i<gridsize; i++){
    float x = ((float)(i))/gridsize;
    for (j=1; j<gridsize; j++){
      float y = ((float)(j))/gridsize;
      glVertex3f(x, y, 0.0);
      float xv = xVectorF(x, y);
      float yv = yVectorF(x, y);
      float d = sqrt(pow(xv, 2.0f) + pow(yv, 2.0f));
      float xx = x + veclen*xv;
      float yy = y + veclen*yv;
      glVertex3f(xx, yy, 0.0);
    }
  }
  glEnd();

  glColor3f(1.0, 0.1, 0.1);
  glBegin(GL_POINTS);
  for (i=1; i<gridsize; i++){
    float x = ((float)(i))/gridsize;
    for (j=1; j<gridsize; j++){
      float y = ((float)(j))/gridsize;
      glVertex3f(x, y, 0.0);
    }
  }
  glEnd();

}

void Draw() {
  glClear(GL_COLOR_BUFFER_BIT);

  glColor3f(0.888, 0.999, 0.909);
  glBegin(GL_POLYGON);
  glVertex3f(x_1, y_1, 0.0);
  glVertex3f(x_2, y_1, 0.0);
  glVertex3f(x_2, y_2, 0.0);
  glVertex3f(x_1, y_2, 0.0);
  glEnd();

  drawGrid();

  drawParticles();

  glutSwapBuffers();

  T = T + dt;
  printf("time :: %f\n", T);
}

void Timer(){
  glutPostRedisplay();
  glutTimerFunc(30, Timer, 0);
}

void Initialize() {
  glClearColor(1.0, 1.0, 1.0, 0.0);
  //glClearColor(0.678, 0.679, 0.684, 0.0);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(0.0, 1.0, 0.0, 1.0, -1.0, 1.0);
  glPointSize(3);
  glLineWidth(2);
}

int main(int argc, char** argv) {

  initParticles();

  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(640, 640);
  glutInitWindowPosition(200, 200);
  glutCreateWindow("The Snake...");
  Initialize();
  // Set up callback functions for key presses
  glutKeyboardFunc( keyPress );
  glutSpecialFunc(specialKey);

  glutDisplayFunc(Draw);
  Timer();
  glutMainLoop();
  return 0;
}
